{
  "version": 3,
  "sources": ["../src/utils.ts", "../src/config.ts", "../src/visualizer.ts"],
  "sourcesContent": ["type Point = {\n  x: number;\n  y: number;\n}\n\nexport function smoothPoints(points: Point[], windowSize: number, canvasWidth: number): Point[] {\n  if (points.length <= windowSize) return points;\n\n  const smoothed: Point[] = [];\n\n  smoothed.push(points[0]);\n\n  for (let i = 1; i < points.length - 1; i++) {\n    // const adaptiveWindow = Math.min(\n    const adaptiveWindow = Math.max(\n      2,\n      Math.floor(windowSize * Math.pow((points[i].x / canvasWidth), 2) * 3)\n    );\n\n    const halfWindow = Math.floor(adaptiveWindow / 2);\n    const startIdx = Math.max(0, i - halfWindow);\n    const endIdx = Math.min(points.length - 1, i + halfWindow);\n\n    let sumY = 0;\n    for (let j = startIdx; j <= endIdx; j++) {\n      sumY += points[j].y;\n    }\n\n    const avgY = sumY / (endIdx - startIdx + 1);\n    smoothed.push({ x: points[i].x, y: avgY });\n  }\n\n  if (points.length > 1) {\n    smoothed.push(points[points.length - 1]);\n  }\n\n  return smoothed;\n}\n", "import { Compresor, actualizarValorCompresor } from \"./compressor.js\";\nexport let activeFrequencyMarker: number | null = null;\nexport let activeQMarker: number | null = null;\nexport let compresorActivo: boolean = false;\nexport let staticFiltering: boolean = false;\nexport const filters = [\"sub\", \"bass\", \"lowMid\", \"mid\", \"highMid\", \"high\", \"air\"];\nexport let compresorParams: Compresor = {\n  threshold: -24,\n  ratio: 4,\n  knee: 30,\n  attack: 0.003,\n  release: 0.25\n};\n\nexport function setActiveFrequencyMarker(frequency: number | null) { activeFrequencyMarker = frequency; }\nexport function getActiveFrequencyMarker() { return activeFrequencyMarker; }\nexport function setActiveQMarker(q: number | null) { activeQMarker = q; }\nexport function getActiveQMarker() { return activeQMarker; }    \nexport function setCompresorActivo(activo: boolean) { compresorActivo = activo; }\nexport function getCompresorActivo() { return compresorActivo; }\nexport function setCompresorParam(param: keyof Compresor, value: number) { \n    compresorParams[param] = value; \n    actualizarValorCompresor(param, value);\n}\nexport function getCompresorParam(param: keyof Compresor) { return compresorParams[param]; }\n", "import { smoothPoints } from \"./utils.js\";\nimport { getActiveFrequencyMarker, getActiveQMarker } from \"./config.js\";\n\ntype VisualizerData = {\n    pre: number[];\n    mid: number[];\n    post: number[];\n    minDecibels: number;\n    maxDecibels: number;\n}\n\n// export function drawVisualizer(data: { [key: string]: number[] | number }) {\nexport function drawVisualizer(data: VisualizerData) {\n  const preData: number[] = data[\"pre\"] || [];\n  const midData: number[] = data[\"mid\"] || [];\n  const postData: number[] = data[\"post\"] || [];\n  const minDecibels: number = data[\"minDecibels\"] || -100;\n  const maxDecibels: number = data[\"maxDecibels\"] || -25;\n  const canvas = document.getElementById(\"visual\");\n  let ctx: CanvasRenderingContext2D | null = null;\n  if (canvas instanceof HTMLCanvasElement) {\n    ctx = canvas.getContext(\"2d\");\n    if (!ctx) throw new Error(\"Critical: Canvas context not found or 'visual' element is not a canvas.\");\n  } else {\n    throw new Error(\"Critical: 'visual' element is not a canvas.\");\n  }\n\n  const bufferLength = preData.length;\n\n  // Detectar si el modo oscuro est\u00E1 activo\n  const isDarkMode = document.body.classList.contains('dark-mode');\n  \n  // Fondo adaptado al tema actual\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.fillStyle = isDarkMode ? \"#121212\" : \"#fefefe\"; // Oscuro o claro seg\u00FAn el tema\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n  // Funci\u00F3n para normalizar valores de dB a altura de barra (0-1)\n  const normalizeDb = (dbValue: number) => {\n    // Limitar el valor entre minDecibels y maxDecibels\n    const clampedDb = Math.max(minDecibels, Math.min(maxDecibels, dbValue));\n    // Normalizar a un valor entre 0 y 1\n    return (clampedDb - minDecibels) / (maxDecibels - minDecibels);\n  };\n\n  // Dibujar escala de frecuencia logar\u00EDtmica\n  ctx.fillStyle = isDarkMode ? \"#aaaaaa\" : \"#aaa\";\n  ctx.font = \"10px Arial\";\n  const freqLabels = [30, 60, 120, 250, 500, 1000, 2000, 4000, 8000, 17000];\n  freqLabels.forEach((freq, index) => {\n    // Convertir frecuencia a posici\u00F3n X usando escala de octavas\n    const octave = Math.log2(freq / 20); // N\u00FAmero de octavas desde 20Hz\n    const totalOctaves = Math.log2(17000 / 20); // Aproximadamente 9.7 octavas (hasta 17kHz)\n    let x = (octave / totalOctaves) * canvas.width;\n    \n    // Aplicar offset a todas las l\u00EDneas excepto la \u00FAltima (17kHz)\n    if (index < freqLabels.length - 1) {\n      const offsetFactor = 1 - (index / (freqLabels.length - 1));\n      x += 10 * offsetFactor;\n    }\n    \n    // Dibujar l\u00EDnea vertical\n    ctx.strokeStyle = isDarkMode ? \"#333333\" : \"#ddd\";\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(x, 0);\n    ctx.lineTo(x, canvas.height);\n    ctx.stroke();\n    \n    // Dibujar etiqueta\n    ctx.fillStyle = isDarkMode ? \"#e0e0e0\" : \"#333\";\n    ctx.fillText(freq >= 1000 ? `${freq/1000}k` : freq.toString(), x - 10, canvas.height - 5);\n  });\n\n  // Dibujar escala de dB\n  const dbLabels = [-90, -80, -70, -60, -50, -40, -30];\n  dbLabels.forEach(db => {\n    const y = canvas.height - (normalizeDb(db) * canvas.height);\n    \n    // Dibujar l\u00EDnea horizontal\n    ctx.strokeStyle = isDarkMode ? \"#333333\" : \"#eee\";\n    ctx.beginPath();\n    ctx.moveTo(0, y);\n    ctx.lineTo(canvas.width, y);\n    ctx.stroke();\n    \n    // Dibujar etiqueta\n    ctx.fillStyle = isDarkMode ? \"#e0e0e0\" : \"#333\";\n    ctx.fillText(`${db} dB`, 5, y + 12);\n  });\n\n  // Calcular posiciones de puntos en escala de octavas\n  const prePoints = [];\n  const midPoints = []; \n  const postPoints = [];\n  \n  // Crear posiciones de puntos en escala de octavas\n  for (let i = 0; i < bufferLength; i++) {\n    // Calculamos la frecuencia correspondiente a cada bin de la FFT\n    // La FFT divide el rango de frecuencias en partes iguales (lineales)\n    // Pero queremos visualizarlas en escala de octavas\n    const freqRatio = i / bufferLength; // Posici\u00F3n relativa en el array (0-1)\n    const nyquistFreq = 22050; // Frecuencia m\u00E1xima representable (sampleRate/2)\n    \n    // Frecuencia lineal correspondiente al bin i de la FFT\n    const linearFreq = freqRatio * nyquistFreq;\n    \n    // Solo procesamos hasta 17kHz\n    if (linearFreq > 17000) break;\n    \n    // Solo incluimos frecuencias desde 20Hz\n    if (linearFreq < 20) continue;\n    \n    // Convertir frecuencia a posici\u00F3n X usando escala de octavas\n    const octave = Math.log2(linearFreq / 20); // N\u00FAmero de octavas desde 20Hz\n    const totalOctaves = Math.log2(17000 / 20); // Aproximadamente 9.7 octavas (hasta 17kHz)\n    const x = (octave / totalOctaves) * canvas.width * 0.995; // Usar el valor exacto de octavas\n    \n    // Almacenar puntos con sus valores de amplitud\n    if (i < preData.length) {\n      const y = canvas.height - (normalizeDb(preData[i]) * canvas.height);\n      prePoints.push({ x, y });\n    }\n    \n    // Nuevo: almacenar puntos para el visualizador intermedio\n    if (i < midData.length) {\n      const y = canvas.height - (normalizeDb(midData[i]) * canvas.height);\n      midPoints.push({ x, y });\n    }\n    \n    if (i < postData.length) {\n      const y = canvas.height - (normalizeDb(postData[i]) * canvas.height);\n      postPoints.push({ x, y });\n    }\n  }\n  \n  // Aplicar suavizado a los puntos\n  const smoothedPrePoints = smoothPoints(prePoints, 7, canvas.width);\n  const smoothedMidPoints = smoothPoints(midPoints, 7, canvas.width); \n  const smoothedPostPoints = smoothPoints(postPoints, 7, canvas.width);\n  \n  // Efecto glow\n  ctx.shadowBlur = 10;\n  ctx.shadowOffsetX = 0;\n  ctx.shadowOffsetY = 0;\n\n  // Pre-EQ: violeta vivo con glow\n  ctx.shadowColor = \"rgba(190, 90, 255, 0.4)\";\n  ctx.strokeStyle = \"rgba(190, 90, 255, 0.8)\";\n  ctx.fillStyle = \"rgba(190, 90, 255, 0.3)\";\n  ctx.lineWidth = 2;\n  \n  // Dibujar l\u00EDnea para pre-EQ\n  ctx.beginPath();\n  ctx.moveTo(0, canvas.height); \n  \n  // Dibujar la l\u00EDnea que une los puntos\n  smoothedPrePoints.forEach(point => {\n    ctx.lineTo(point.x, point.y);\n  });\n  \n  // Cerrar el path hasta la base\n  ctx.lineTo(canvas.width, canvas.height);\n  ctx.closePath();\n  \n  // Rellenar el \u00E1rea bajo la curva\n  ctx.fill();\n  \n  // Dibujar la l\u00EDnea del contorno\n  ctx.beginPath();\n  if (smoothedPrePoints.length > 0) {\n    ctx.moveTo(smoothedPrePoints[0].x, smoothedPrePoints[0].y);\n    for (let i = 1; i < smoothedPrePoints.length; i++) {\n      ctx.lineTo(smoothedPrePoints[i].x, smoothedPrePoints[i].y);\n    }\n    ctx.stroke();\n  }\n\n  // Nuevo: Mid-EQ (despu\u00E9s de filtros, antes de compresor): amarillo/naranja con glow\n  ctx.shadowColor = \"rgba(255, 180, 50, 0.4)\";\n  ctx.strokeStyle = \"rgba(255, 180, 50, 0.8)\";\n  ctx.fillStyle = \"rgba(255, 180, 50, 0.3)\";\n  \n  // Dibujar l\u00EDnea para mid-EQ\n  ctx.beginPath();\n  ctx.moveTo(0, canvas.height); \n  \n  // Dibujar la l\u00EDnea que une los puntos\n  smoothedMidPoints.forEach(point => {\n    ctx.lineTo(point.x, point.y);\n  });\n  \n  // Cerrar el path hasta la base\n  ctx.lineTo(canvas.width, canvas.height);\n  ctx.closePath();\n  \n  // Rellenar el \u00E1rea bajo la curva\n  ctx.fill();\n  \n  // Dibujar la l\u00EDnea del contorno\n  ctx.beginPath();\n  if (smoothedMidPoints.length > 0) {\n    ctx.moveTo(smoothedMidPoints[0].x, smoothedMidPoints[0].y);\n    for (let i = 1; i < smoothedMidPoints.length; i++) {\n      ctx.lineTo(smoothedMidPoints[i].x, smoothedMidPoints[i].y);\n    }\n    ctx.stroke();\n  }\n\n  // Post-EQ: verde ne\u00F3n claro con glow\n  ctx.shadowColor = \"rgba(50, 220, 120, 0.4)\";\n  ctx.strokeStyle = \"rgba(50, 220, 120, 0.8)\";\n  ctx.fillStyle = \"rgba(50, 220, 120, 0.3)\";\n  \n  // Dibujar l\u00EDnea para post-EQ\n  ctx.beginPath();\n  ctx.moveTo(0, canvas.height); // Empezar desde la esquina inferior izquierda\n  \n  // Dibujar la l\u00EDnea que une los puntos\n  smoothedPostPoints.forEach(point => {\n    ctx.lineTo(point.x, point.y);\n  });\n  \n  // Cerrar el path hasta la base\n  ctx.lineTo(canvas.width, canvas.height);\n  ctx.closePath();\n  \n  // Rellenar el \u00E1rea bajo la curva\n  ctx.fill();\n  \n  // Dibujar la l\u00EDnea del contorno\n  ctx.beginPath();\n  if (smoothedPostPoints.length > 0) {\n    ctx.moveTo(smoothedPostPoints[0].x, smoothedPostPoints[0].y);\n    for (let i = 1; i < smoothedPostPoints.length; i++) {\n      ctx.lineTo(smoothedPostPoints[i].x, smoothedPostPoints[i].y);\n    }\n    ctx.stroke();\n  }\n\n  // Limpiar efectos\n  ctx.shadowBlur = 0;\n  ctx.shadowColor = \"transparent\";\n\n  // Agregar leyenda para los colores\n  const legendY = 20;\n  const legendSpacing = 120;\n  \n  // Leyenda para Pre-EQ (violeta)\n  ctx.fillStyle = \"rgba(190, 90, 255, 0.8)\";\n  ctx.fillRect(10, legendY - 10, 10, 10);\n  ctx.fillStyle = isDarkMode ? \"#e0e0e0\" : \"#333\";\n  ctx.fillText(\"Pre-EQ\", 25, legendY);\n  \n  // Leyenda para Mid-EQ (amarillo/naranja)\n  ctx.fillStyle = \"rgba(255, 180, 50, 0.8)\";\n  ctx.fillRect(10 + legendSpacing, legendY - 10, 10, 10);\n  ctx.fillStyle = isDarkMode ? \"#e0e0e0\" : \"#333\";\n  ctx.fillText(\"Post-Filtros\", 25 + legendSpacing, legendY);\n  \n  // Leyenda para Post-EQ (verde)\n  ctx.fillStyle = \"rgba(50, 220, 120, 0.8)\";\n  ctx.fillRect(10 + legendSpacing * 2, legendY - 10, 10, 10);\n  ctx.fillStyle = isDarkMode ? \"#e0e0e0\" : \"#333\";\n  ctx.fillText(\"Post-Compresor\", 25 + legendSpacing * 2, legendY);\n\n  // Dibujar el marcador de frecuencia activa si existe\n  const activeFrequencyMarker = getActiveFrequencyMarker();\n  const activeQMarker = getActiveQMarker();\n  if (activeFrequencyMarker) {\n    // Convertir frecuencia a posici\u00F3n X usando escala de octavas\n    const octave = Math.log2(activeFrequencyMarker / 20); // N\u00FAmero de octavas desde 20Hz\n    const totalOctaves = Math.log2(17000 / 20); // Aproximadamente 9.7 octavas (hasta 17kHz)\n    const x = (octave / totalOctaves) * canvas.width * 0.995; // Usar el valor exacto de octavas\n    \n    ctx.lineWidth = 2;\n    ctx.strokeStyle = \"#ff3366\"; // Color llamativo para el marcador\n    ctx.beginPath();\n    ctx.moveTo(x, 0);\n    ctx.lineTo(x, canvas.height);\n    ctx.stroke();\n    \n    // Etiqueta con el valor de frecuencia\n    ctx.fillStyle = \"#ff3366\";\n    ctx.font = \"12px Arial\";\n    ctx.fillText(`${activeFrequencyMarker} Hz`, x + 5, 15);\n    \n    // Dibujar la campana de Q si tenemos tanto frecuencia como Q\n    if (activeQMarker) {\n      // Dibujar la campana\n      ctx.beginPath();\n      ctx.strokeStyle = \"rgba(255, 51, 102, 0.7)\";\n      ctx.fillStyle = \"rgba(255, 51, 102, 0.2)\";\n      \n      // Calcular la escala de la campana basada en Q\n      // Cuanto mayor sea Q, m\u00E1s estrecha ser\u00E1 la campana\n      const qScale = Math.max(20, 200 / activeQMarker); // Limitar el m\u00EDnimo para Q muy altos\n      \n      // Dibujar la curva de campana\n      ctx.beginPath();\n      \n      // Puntos para la curva\n      const points = [];\n      const centerX = x;\n      const height = canvas.height * 0.7; // Altura m\u00E1xima de la campana\n      \n      // Generar puntos para la curva de campana en escala logar\u00EDtmica\n      for (let i = -canvas.width/2; i <= canvas.width/2; i += 5) {\n        const pointX = centerX + i;\n        if (pointX >= 0 && pointX <= canvas.width) {\n          // Convertir posici\u00F3n X a frecuencia\n          const freq = 20 * Math.pow(10, (pointX / canvas.width) * Math.log10(17000 / 20));\n          const freqRatio = freq / activeFrequencyMarker;\n          \n          // F\u00F3rmula de campana para filtro peaking en escala logar\u00EDtmica\n          const response = 1 / Math.sqrt(1 + Math.pow(activeQMarker * (freqRatio - 1/freqRatio), 2));\n          const pointY = canvas.height - height * response;\n          \n          points.push({x: pointX, y: pointY});\n        }\n      }\n      \n      // Dibujar la curva\n      if (points.length > 0) {\n        ctx.beginPath();\n        ctx.moveTo(points[0].x, points[0].y);\n        for (let i = 1; i < points.length; i++) {\n          ctx.lineTo(points[i].x, points[i].y);\n        }\n        ctx.stroke();\n        \n        // Rellenar el \u00E1rea bajo la curva\n        ctx.lineTo(points[points.length-1].x, canvas.height);\n        ctx.lineTo(points[0].x, canvas.height);\n        ctx.closePath();\n        ctx.fill();\n        \n        // Mostrar el valor de Q\n        ctx.fillStyle = \"#ff3366\";\n        ctx.fillText(`Q: ${activeQMarker.toFixed(1)}`, x + 5, 30);\n      }\n    }\n  }\n}"],
  "mappings": "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",
  "names": ["smoothPoints", "points", "windowSize", "canvasWidth", "smoothed", "i", "adaptiveWindow", "halfWindow", "startIdx", "endIdx", "sumY", "j", "avgY", "activeFrequencyMarker", "activeQMarker", "getActiveFrequencyMarker", "activeFrequencyMarker", "getActiveQMarker", "activeQMarker", "drawVisualizer", "data", "preData", "midData", "postData", "minDecibels", "maxDecibels", "canvas", "ctx", "bufferLength", "isDarkMode", "normalizeDb", "dbValue", "freqLabels", "freq", "index", "octave", "totalOctaves", "x", "offsetFactor", "db", "y", "prePoints", "midPoints", "postPoints", "i", "linearFreq", "smoothedPrePoints", "smoothPoints", "smoothedMidPoints", "smoothedPostPoints", "point", "legendY", "legendSpacing", "activeFrequencyMarker", "getActiveFrequencyMarker", "activeQMarker", "getActiveQMarker", "qScale", "points", "centerX", "height", "pointX", "freqRatio", "response", "pointY"]
}
